{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DLMS.dev","text":"<p>Resources for the python library <code>dlms-cosem</code> and general DLMS/COSEM</p>"},{"location":"#about","title":"About","text":"<p><code>dlms-cosem</code> is a protocol and client library for DLMS/COSEM. It is mainly used for communication with energy meters.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dlms-cosem\n</code></pre> <p>Note</p> <p>We only support Python 3.6+</p>"},{"location":"#design","title":"Design","text":"<p><code>dlms-cosem</code> is designed to be a tool with a simple API for working with DLMS/COSEM enabled energy meters. It provides the lowest level function, as protocol state management, APDU encoding/decoding, APDU encryption/decryption.</p> <p>The library aims to provide a sans-io implementation of the DLMS/COSEM protocol so that the protocol code can be reused with several different io-paradigms. As of now we provide a simple client implementation based on blocking I/O.</p> <p>We have not implemented full support to be able to build a server (meter) emulator. If this is a use-case you need, consider sponsoring the development and contact us.</p>"},{"location":"#supported-meters","title":"Supported meters","text":"<p>Technically we aim to support any DLMS enabled meter. But since the library is low level DLMS you might need an abstraction layer to support everything in your meter.</p> <p>DLMS/COSEM specifies many different ways of performing tasks on a meter. It is customary that a meter also adheres to a companion standard. In the companion standard it is defined exactly how certain use-cases are to be performed and how data is modeled.</p> <p>Examples of companion standards are:</p> <ul> <li>DSMR (Netherlands)</li> <li>IDIS (all Europe)</li> <li>UNI/TS 11291 (Italy)</li> </ul> <p>On top of it all your DSO (Distribution Service Operator) might have ordered their meters with extra functionality or reduced functionality from one of the companion standards.</p> <p>We have some meters we have run tests on or know the library is used for in production</p> <ul> <li>Pietro Fiorentini RSE 1,2 LA N1. Italian gas meter</li> <li>Iskraemeco AM550. IDIS compliant electricity meter.</li> </ul>"},{"location":"#development","title":"Development","text":"<p>This library is developed by Palmlund Wahlgren Innovative Technology AB. We are based in Sweden and are members of the DLMS User Association.</p> <p>If you find a bug pleas raise an issue on Github.</p> <p>We welcome contributions of any kind.</p> <p>We add features depending on our own use cases and our clients use cases. If you need a feature implemented please contact us.</p>"},{"location":"#training-consultancy-commercial-support","title":"Training / Consultancy / Commercial Support","text":"<p>We offer consultancy service and training services around this library and general DLMS/COSEM. If you are interested in our services just reach out to us.</p> <p>If you have implemented a solution based on this library we also offer a commercial support scheme.</p>"},{"location":"api_design/","title":"API Design","text":"<p>We want a simple API for the actions you perform on objects in a DLMS meter. DLSM follows a request/response flow.</p> <p>Simillar to how redis can pipeline actions there is the possiblite to \"pipeline\" commands in DLMS with the ACCESS service where several actions can be \"clumped together in on request\"</p> <p>The client should take care of association aquire and release without the user needing to set it up. It should also be possible to set up a predefined assosiation and skip the aquire and release.</p> <pre><code>with Client() as client:\n    response = client.set(\"1.2.3.4.5\", 2, \"test\")\n</code></pre> <p>But this is a bit too simple since we need to know how to model the objects in the meter.</p> <p>There should be a way of defining the objects available in the meter beforehand or set it up as the request goes away. Then if something is wrong in the calling a proper error can be generated.</p> <pre><code>with Client() as client:\n    response = client.set(\n        logical_name=LogicalNameReference(a=1, b=2, c=3, d=4, e=5, f=5)\n        interface=PushInterfaceV2,\n        attribute=2,\n        value=\"test\"\n        )\n    # above should be the same as\n    response = client.set(\"1.2.3.4.5\", 2, \"test\")\n    # if we know that the PushInterface is on LN 1.2.3.4.5 beforehand\n    # It could be a simple dict.\n\n    # it would also make it possible to use something like:\n    response = client[\"1.2.3.4.5\"][0] # to initate a get in the attribute.\n    # or\n    response = client[\"1.2.3.4.5\"].set(2, \"test\")\n</code></pre> <p>Since we want automatic handling of assiciation aquire and relase we need to set up the client with data so it can handle it for us.</p> <pre><code>with Client(encryption_key=\"0f0f\", security_setup=x, proposed_conformance=Conformance() as client:\n    response = client.set(\"1.2.3.4.5\", 2, \"test\")\n</code></pre> <p>Should result in an AARQ is sent according to association. Set up dedicated key encryption, handle HLS password transfer, etc. When you then send a SET (WriteRequestApdu) it should be automatically encrypted with the global or dedicated key. If block is supported in conformance it should be split into blocks and sent. The response should be received and when it is fully received it should be decrypted and returned to the user.</p> <p>By having the \"heavy stuff\" handled in the background it makes it possbile to keep a simple API while adding incfreasing functionallity to the middlestack.</p> <p>We also need to add a certain transport to the client so it can send its data to the meter. HDLC and IP should be implemented. Maybe HDLC_over_IP. But since that is in the IO part it can easily be broken out and extended as needed, supporting asyncio or whatever.</p> <p>The main part of the protocol implementation should still be sans-io.</p> <p>client.set()  -&gt; SetRequest    -&gt; GlobalCipheredApdu       -&gt; Block, Block, Block       -&gt; connection.send(\"data\")       -&gt; data is sent over wire.       &lt;- data is received.       &lt;- Block, Block, Block    &lt;- GlobalCipheredApdu  &lt;- SetResponse</p> <p>The client should be in the background and an abstraction should face the user (if the want to). Ex classname: Meter The Meter class holds information on all objects on the meter. By reading the object list of the an association it is possible to get a list of all objects and the access rights on each attribute and method. Even the selective access information is available. But the attribute are different for each interface type and the data you read from them or write to them are different. Many interfaces attributes have a static value. We want the opportunity to predefine the static data so that we automatically can interpret the data returned from the dynamic attributes. For example a profile generic: To be able to interpret the buffer we need to know the captured_object. To be able to interpret the values in the buffer we need to look up the object (ic=DATA just holds a value, ic=Register holds a dynamic value and static information about the scalar and the unit.)</p> <p>So we want a way to read the current assosiation list For every instance object we would like to read all the static information. This should then be outputted into a file. yaml for humans or json for machines. By supplying the file to the Meter class it is possible to call instances and get values back. If we don't have access to do something raise an Exception.</p> <p>Example file structure: <pre><code>objects:\n  1.2.3.4.5:\n    interface_class: 3  # Register\n    version: 0\n    attributes:\n      1: \"1.2.3.4.5\"  # Logical Name\n      3:\n        scalar: 3\n        unit: 13\n  0.0.99.0.0.255:\n    interface_class: 7  # Profile Generic\n    version: 1\n    attributes:\n      1: \"0.0.99.0.0.255\"  # Logical Name\n      3:   # capture objects\n        - interface: 3\n          instance: \"1.2.3.4.5\"\n          attribute: 2\n          data_index: 0\n        - interface: 3\n          instance: \"2.2.3.4.5\"\n          attribute: 2\n          data_index: 0\n        - interface: 3\n          instance: \"3.2.3.4.5\"\n          attribute: 2\n          data_index: 0\n      4: 60  # capture period\n      5: 1  # sort method\n      6:   # sort object\n          interface: 3\n          instance: \"1.2.3.4.5\"\n          attribute: 2\n          data_index: 0\n      8: 30  # profile_entries\n    selective_access:\n      2:\n        - 1\n        - 2\n    access_rights:\n      1:\n        - 1\n        - 2\n        - 3\n        - 4\n        - 5\n        - 6\n        - 7\n        - 8\n</code></pre></p> <p><pre><code>meter = Meter.from_json(my_json_file)\nmeter.get(\"1.2.3.4.5\", 2, selective_access=make_range_descriptor())\n\n# pipelineing access\naccess = meter.access()\naccess.get()\naccess.set()\naccess.action()\naccess.execute()\n\n# same as\naccess = meter.access().get().set().action().execute()\n\nload_profile = (\n    meter.objects.get(\"1.2.3.4.5\", 2)\n    .filter_range(from_value=\"2020-02-03\", to_value=\"2020-03-03\")\n    .filter_columns(from_value=2, to_value=3)\n)\n\n\nmeter[\"1.2.3.4.5\"].capture_objects\n</code></pre> s</p>"},{"location":"connect_to_your_meter/","title":"Connect to your meter","text":""},{"location":"connect_to_your_meter/#get-an-optical-probe","title":"Get an optical probe","text":"<p>The simplest way to start reading data from your meter is via the optical port. You will need an optical probe to read the data, like these ones.</p> <p>There are many makes of probes. Usually each meter manufacturer also sells a variant, but they can be a bit pricey, however they are usually of good quality.</p>"},{"location":"connect_to_your_meter/#is-your-meter-using-direct-hdlc-or-iec62056-21-mode-e-handshake","title":"Is your meter using direct HDLC or IEC62056-21 Mode E handshake?","text":"<p>This library, as of now, just supports the direct HDLC enabled meters.</p> <p>When you have a meter using IEC62045-21 you need to start with an IEC62056-21 initiation sequence before you can start the HDLC session. Meters have it this way to enable users to still read the meter via the optical port using the simpler IEC62056-21 protocol. Check out our python library for IEC62056-21</p>"},{"location":"connect_to_your_meter/#find-out-how-to-address-your-meter","title":"Find out how to address your meter.","text":"<p>When using HDLC you will need to know the physical address to use in HDLC communications. This is not something that is standardized, and you might have to try different values to get it to work.</p> <p>Here are some values we have gathered:</p> Manufacturer Meter client physical address server (meter) physical address Iskraemeco AM550 1 17"},{"location":"connect_to_your_meter/#is-your-meter-protected","title":"Is your meter protected?","text":"<p>Most meters have at least two association options. You can connect to the public part via the <code>public_client</code> of the meter to read non sensitive data but for reading current and historical values you will need to use the <code>management client</code></p> <p>These addresses are reffered as logical addresses. A meter can have several logical devices in one physical meter (mostly its just one) so the <code>server_logical_address</code> is to address which logical device in the meter you want to connect to and the <code>client_logical_address</code> shows with what kind of client privileges you want to connect with.</p> <p>The public client uses <code>client_logical_address=16</code> and the management client uses <code>client_logical_address=1</code>.</p> <p>Other addresses can be used for clients with specific privileges or for pre-established associations. This is up the meter manufacturer and/or the companion standard the meter supports to define.</p>"},{"location":"connect_to_your_meter/#password","title":"Password","text":"<p>A meter can use no security, Low Level Security (LLS) or High Level Security for the authenticating against the meter</p> <p>No security means that no password needs to be submitted.</p> <p>Low Level Security just means a password needs to be submitted.</p> <p>High level security involves several passes with exchange of challenges between the client and meter and then verifying those challenges. Several methods of validating the challenge exists.</p> <ul> <li>Manufacturer specific</li> <li>MD5</li> <li>SHA1</li> <li>GMAC</li> <li>SHA256</li> <li>ECDSA</li> </ul> <p>As of now <code>dlms-cosem</code> supports HLS-GMAC</p>"},{"location":"connect_to_your_meter/#encryption-and-authentication","title":"Encryption and authentication","text":"<p>Your meter might enforce encryption and/or authentication of messages. If you don't have the keys it will be impossible to communicate with your meter.</p> <p>Each encryption key also have an invocation counter. This is to protect the meter from replay attacks. After each use the invocation counter needs to be incremented. If the meter receives a message with an invocation counter that is the same or lower than in the last message it will discard the message.</p> <p>If you don't know the current invocation counter you can usually read it from the meter using the public client.</p> <p>It is also possible to sign messages and use a public key infrastructure for encryption, but it is not yet supported in <code>dlms-cosem</code></p>"},{"location":"connect_to_your_meter/#security-suite","title":"Security Suite","text":"<p>A meter also usually adheres to a security suite (0-2). All this does is defining what cryptographic functions should be used for certain cryptographic operations.</p> Operation Security Suite 0 Security Suite 1 Security Suite 2 Authenticated Encryption AES-GCM-128 AES-GCM-128 AES-GCM-256 Key Transport AES-GCM-128 AES-GCM-128 AES-GCM-256 Digital Signature NA ECDSA with P-256 ECDSA with P-384 Key Agreement NA ECDSA with P-256 ECDSA with P-384 Hash NA SHA-256 SHA-384 Compression NA v.44 v.44 <p>For now the most important take away from the security suite is to make sure you are using keys of the correct length.</p>"},{"location":"connect_to_your_meter/#simple-example","title":"Simple example","text":"<pre><code>from dlms_cosem.client import DlmsClient\nfrom dlms_cosem import cosem, enumerations\n\nusb_port: str = \"/dev/tty.usbserial-A704H991\"\n\n# public client\ndlms_client = DlmsClient.with_serial_hdlc_transport(serial_port=usb_port,\n                                                    server_logical_address=1,\n                                                    server_physical_address=17,\n                                                    client_logical_address=16, )\n\n# Send HDLC connection and send an ApplicationAssociationRequest (AARQ)\ndlms_client.associate()\n\n# read an invocation counter\ndata: bytes = dlms_client.get(\n    cosem.CosemAttribute(interface=enumerations.CosemInterface.DATA,\n                         instance=cosem.Obis(0, 0, 0x2B, 1, 0), attribute=2, ))\n\n# Release the association by sending a ReleaseRequest and then closing the HDLC connection\ndlms_client.release_association()\n\n# alternatively use the contextmanager .session() to handle the association and\n# connection automatically.\nwith dlms_client.session() as client:\n    data: bytes = client.get(\n        cosem.CosemAttribute(interface=enumerations.CosemInterface.DATA,\n                             instance=cosem.Obis(0, 0, 0x2B, 1, 0), attribute=2, ))\n</code></pre>"},{"location":"dlms_cosem/","title":"About DLMS/COSEM","text":"<p>DLMS/COSEM (IEC 62056, EN13757-1) is the global standard for smart energy metering, control and management. It specifies an object-oriented data model, an application layer protocol and media-specific communication profiles.</p> <p>DLMS/COSEM comprises three key components:</p>"},{"location":"dlms_cosem/#dlms","title":"DLMS","text":"<p>Device Language Message Specification - the application layer protocol that turns the information held by COSEM objects into messages.</p> <p>DLMS/COSEM can be used for all utilities / energy kinds, all market segments, all applications and over virtually any communication media.</p>"},{"location":"dlms_cosem/#cosem","title":"COSEM","text":"<p>Companion Specification for Energy Metering - the object model capable of  describing virtually any application.</p>"},{"location":"dlms_cosem/#obis","title":"OBIS","text":"<p>Object Identification System, the naming system of the objects</p>"},{"location":"dlms_cosem/#cosem-companion-specification-for-energy-metering","title":"COSEM  (Companion Specification for Energy Metering)","text":"<p>The COSEM object model describes the semantics of the language.</p> <p>COSEM interface classes and their instantiations (objects) can be readily used for modelling metering use cases, yet general enough to model any application.</p> <p>Object modelling is a powerful tool to formally represent simple or complex data. Each aspect of the data is modelled with an attribute. Objects may have several attributes and also methods to perform operations on the attributes.</p> <p>Objects can be used in combinations, to model simple use cases such as register reading or more complex ones such as tariff and billing schemes or load management.</p>"},{"location":"dlms_cosem/#obis-object-identification-system","title":"OBIS  (Object Identification System)","text":"<p>OBIS is the naming system of COSEM objects.</p> <p>OBIS codes are specified for electricity, gas, water, heat cost allocators (HCAs) and thermal energy metering, as well as for abstract data that are not related to the energy kind measured.</p> <p>The hierarchical structure of OBIS allows classifying the characteristics of the data e.g. electrical energy \u2013 active power \u2013 integration \u2013 tariff \u2013 billing period.</p>"},{"location":"dlms_cosem/#dlms-cosem-application-layer-services","title":"DLMS /COSEM application layer services","text":"<p>DLMS stands for Device Language Message Specification</p> <p>The syntax of the language is specified by the DLMS services.</p> <p>DLMS/COSEM uses a client-server model where the end devices, typically meters are the servers and the Head End Systems are the clients.</p> <p>The DLMS/COSEM application layer provides:</p> <ul> <li>the ACSE services to connect the clients and the servers.</li> <li>the xDLMS services to access the data held by the COSEM objects. The xDLMS   services are the same for each object; this allows new objects to be added   to the model without affecting the application layer.</li> <li>The application layer also builds the messages (APDUs, Application Protocol   Data Units), applies, check and removes cryptographic protection as needed   and manages transferring long messages in blocks.</li> </ul> <p>The messages can transported over virtually any communication media.</p> <p>There are various built-in mechanisms available for optimizing the traffic to the characteristics of the media.</p>"},{"location":"dlms_cosem/#transport","title":"Transport","text":"<p>The application messages can be transported over virtually any communication media.</p> <p>The DLMS/COSEM communication profiles specify, for each communication the protocol stack and the binding of the lower protocol layers to the DLMS/COSEM application layer.</p> <p>Communication profiles are available for:</p> <ul> <li>Local ports, PSTN/GSM: with HDLC data link layer RS232 / RS485;</li> <li>GPRS/LTE/NB-IoT;</li> <li>IPv6, IPv4, TCP and UDP;</li> <li>S-FSK PLC;</li> <li>G3-PLC with UDP/ IPv6;</li> <li>Prime PLC without IP, with IPv6, IPv4, TCP and UDP;</li> <li>Wired and wireless M-Bus;</li> <li>Mesh networks with IPv6 and 6LowPAN;</li> <li>Wi-SUN</li> <li>LoRaWAN</li> </ul>"}]}